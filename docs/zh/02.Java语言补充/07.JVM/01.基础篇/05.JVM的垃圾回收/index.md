#  第一章：垃圾回收

## 1.1 概述

* 之前，我们已经学习过了JVM 组成中的很多部分，如：类加载器、运行时数据区域等。

> [!NOTE]
>
> * ① Java 程序开始运行的时候，首先会通过`类加载器`将`字节码文件`加载进来并保存到`运行时数据区域`中的`方法区`中，接下来`执行引擎`中的`解释器`就开始工作，其会对`字节码信息`中的`字节码指令`进行解释执行，这些`字节码指令`可以将一些对象创建出来，并运行在`运行时数据区域`中的`堆`中。
> * ② 那么，如果`堆`中的这些`对象`，将来不再使用，JVM 就需要帮助我们去将这些对象进行销毁；换言之，这个销毁的工作就需要`执行引擎`中的`垃圾回收器`来完成。
> * ③ 在 JVM 中，通过`垃圾回收器`来回收对象的方式，就称为`自动垃圾回收`。

![](./assets/1.png)

## 1.2 内存泄漏和内存溢出

### 1.2.1 内存泄漏（Memory Leak）

* `内存泄漏`（Memory Leak）指的是程序在动态分配内存后，`未能正确释放不再使用的内存，导致这部分内存无法被再次利用`。随着时间推移，泄漏的内存越来越多，最终可能耗尽可用内存。 

> [!NOTE]
>
> 📌 通俗理解：借了很多书但从不归还，图书馆的书越来越少（图书馆中的书泄漏了），别人就没法借了。

* `内存泄漏`的`常见原因`，如下所示：

| 常见原因                      | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| :one: 未释放动态内存          | 在 C/C++ 中，使用 `malloc`、`new` 等分配内存后，未调用 `free()` 或 `delete` 进行释放。 |
| :two: 长期持有对象引用        | Java、Python 等语言中，静态集合（如 `static List`、`static Map`）持续持有对象引用，导致垃圾回收器无法回收。 |
| :three: 未注销事件监听器/回调 | 注册的事件监听器、定时器（`setInterval`）、回调函数在不再需要时未注销，导致对象被意外引用。 |
| :four: 循环引用               | 在使用引用计数机制的语言（ Python、JavaScript）中，对象之间相互引用形成闭环，引用计数无法归零，导致无法释放内存。 |

* `内存泄漏`的`常见影响`，如下所示：

| 常见影响                         | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| :one: 内存占用持续增长           | 程序运行过程中，已分配但未释放的内存不断累积，导致内存使用量持续上升。 |
| :two: 系统性能下降或崩溃         | 长时间运行后，内存资源耗尽，系统变慢、响应延迟，严重时导致程序或系统崩溃（OOM）。 |
| :three: 程序在内存耗尽前仍可运行 | 内存泄漏初期表现不明显，程序看似正常，直到内存耗尽才暴露问题。 |

* `如何检测和避免`，如下所示：

| 如何检测         | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| :one: 如何检测？ | - **C/C++**: 使用 `Valgrind`、`AddressSanitizer`、Visual Studio 调试器分析内存使用。<br/>- **Java**: 使用 `JProfiler`、`jvisualvm`、`Eclipse MAT` 分析堆内存和对象引用。<br/>- **JavaScript**: 使用 Chrome DevTools 的 Memory 面板进行堆快照和内存录制。<br/>- **Python**: 使用 `tracemalloc`、`memory_profiler`、`objgraph` 检测对象引用和内存分配。 |
| :two: 如何避免？ | - 及时释放资源：确保 `malloc`/`new` 有对应 `free`/`delete`。<br/>- 使用自动资源管理机制：C++ 的 RAII 和智能指针（`unique_ptr`、`shared_ptr`），Java 的 `try-with-resources`。<br/>- 使用弱引用（`WeakReference`、`weakref`）避免长期持有对象。<br/>- 组件销毁时注销事件监听器、清除定时器（如 `removeEventListener`、`clearInterval`）。<br/>- 打破循环引用，合理设计对象关系。<br/>- 加强代码审查，结合自动化工具在 CI/CD 中检测内存问题。 |

### 1.2.2 内存溢出（Memory Overflow）

* `内存溢出`是指程序在申请内存时，`系统没有足够的可用内存分配给它`，导致分配失败，程序崩溃或抛出异常。

> [!NOTE]
>
> 📌 通俗理解：想借一本书，但图书馆已经没书可借了。

* `内存溢出`的`常见原因`，如下所示：

| 常见原因                  | 描述                                                         |
| ------------------------- | ------------------------------------------------------------ |
| :one: 内存泄漏累积        | - 长期未释放内存导致可用内存逐渐减少，最终在内存耗尽时引发溢出。<br>-  内存泄漏是导致内存溢出的常见间接原因。 |
| :two: 处理大量数据        | 程序需要加载超大文件、创建巨型数组或缓存大量对象，如：一次性读取 GB 级文件到内存。 |
| :three: 内存配置过小      | JVM 堆内存设置不足，如： `-Xmx512m` 但实际需求更大，导致 `java.lang.OutOfMemoryError: Java heap space`。 |
| :four: 递归过深导致栈溢出 | 深层递归或无限递归耗尽调用栈空间，引发 `StackOverflowError`（属于内存溢出的特殊形式）。 |

* `内存溢出`的`常见影响`，如下所示：

| 常见影响                 | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| :one: 程序崩溃或抛出异常 | 直接抛出内存溢出异常，如：Java 中的 `java.lang.OutOfMemoryError` 或 `StackOverflowError`，程序终止运行。 |
| :two: 系统不稳定         | 内存耗尽可能导致操作系统强制终止进程，或影响其他进程运行，系统整体响应变慢甚至宕机。 |

* `如何避免`：

| 如何避免                   | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| :one: 合理设置内存限制     | Java 中通过 `-Xmx`（最大堆内存）和 `-Xms`（初始堆内存）合理配置 JVM 内存。 |
| :two: 优化算法与数据处理   | 避免一次性加载大量数据，采用增量处理、懒加载等策略。         |
| :three: 使用流式处理与分页 | 对大文件使用 I/O 流逐块读取；数据库查询使用分页（pagination）避免全量加载。 |
| :four: 引入缓存控制机制    | 使用 LRU、TTL 等策略限制缓存大小，防止缓存无限增长。         |
| :five: 监控内存使用情况    | 利用监控工具，如：Prometheus + Grafana、JConsole、VisualVM，实时观察内存使用趋势，及时预警。 |

### 1.2.3 总结

* 如果我们写了一个服务器程序，那么：

| 应用场景 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 内存泄漏 | 每次处理请求都创建一个缓存对象，但从未清理旧对象 → 内存占用越来越高。 |
| 内存溢出 | 某次请求试图加载一个 10GB 的文件，而系统只有 8GB 可用内存 → 直接崩溃。 |

> [!NOTE]
>
> 📌 通俗理解： 
>
> * ① `内存泄漏`是“慢性病”**，**`内存溢出`是“急性发作”，有时慢性病最终引发了急性发作。
> * ② `内存泄漏`：该还的内存没还 → 资源浪费。
> * ③ `内存溢出`：想借的内存借不到 → 分配失败。
> * ④ `内存泄漏`可能最终导致`内存溢出`；但是，`内存溢出`不一定是因为`内存泄漏`。

* 内存泄漏 VS 内存溢出：

| 特性         | 内存泄漏（Memory Leak）                | 内存溢出（Memory Overflow） |
| ------------ | -------------------------------------- | --------------------------- |
| 本质         | 内存未释放，被“浪费”                   | 内存不够用，申请失败        |
| 是否一定崩溃 | 不一定，可能缓慢恶化                   | 通常导致程序崩溃            |
| 因果关系     | 可能导致内存溢出                       | 是结果，可能由泄漏引起      |
| 常见语言     | C/C++ 更严重；但是，Java/JS 也可能发生 | 所有语言都可能发生          |
| 典型表现     | 内存使用持续上升                       | 突然报错 “Out of Memory”    |

## 1.3 垃圾回收

### 1.2.1 手动垃圾回收

* 对于 C/C++ 这类没有自动垃圾回收机制的语言中，如果一个对象不再使用，就需要手动释放，否则就会出现`内存泄漏`。

![](./assets/2.svg)

* 这种释放对象的过程为`垃圾回收`，而需要程序员编写代码进行回收的方式称为`手动回收`。



* 示例：内存泄漏

::: code-group

```c [main.c]
```

```md:img [cmd 控制台]
```



:::





# 第二章：









# 第三章：