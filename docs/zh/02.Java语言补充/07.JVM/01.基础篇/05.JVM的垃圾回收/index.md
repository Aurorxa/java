#  第一章：垃圾回收

## 1.1 概述

* 之前，我们已经学习过了JVM 组成中的很多部分，如：类加载器、运行时数据区域等。

> [!NOTE]
>
> * ① Java 程序开始运行的时候，首先会通过`类加载器`将`字节码文件`加载进来并保存到`运行时数据区域`中的`方法区`中，接下来`执行引擎`中的`解释器`就开始工作，其会对`字节码信息`中的`字节码指令`进行解释执行，这些`字节码指令`可以将一些对象创建出来，并运行在`运行时数据区域`中的`堆`中。
> * ② 那么，如果`堆`中的这些`对象`，将来不再使用，JVM 就需要帮助我们去将这些对象进行销毁；换言之，这个销毁的工作就需要`执行引擎`中的`垃圾回收器`来完成。
> * ③ 在 JVM 中，通过`垃圾回收器`来回收对象的方式，就称为`自动垃圾回收`。

![](./assets/1.png)

## 1.2 内存泄漏和内存溢出

### 1.2.1 内存泄漏（Memory Leak）

* `内存泄漏`（Memory Leak）指的是程序在动态分配内存后，`未能正确释放不再使用的内存，导致这部分内存无法被再次利用`。随着时间推移，泄漏的内存越来越多，最终可能耗尽可用内存。 

> [!NOTE]
>
> 📌 通俗理解：借了很多书但从不归还，图书馆的书越来越少（图书馆中的书泄漏了），别人就没法借了。

* `内存泄漏`的`常见原因`，如下所示：

| 常见原因                      | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| :one: 未释放动态内存          | 在 C/C++ 中，使用 `malloc`、`new` 等分配内存后，未调用 `free()` 或 `delete` 进行释放。 |
| :two: 长期持有对象引用        | Java、Python 等语言中，静态集合（如 `static List`、`static Map`）持续持有对象引用，导致垃圾回收器无法回收。 |
| :three: 未注销事件监听器/回调 | 注册的事件监听器、定时器（`setInterval`）、回调函数在不再需要时未注销，导致对象被意外引用。 |
| :four: 循环引用               | 在使用引用计数机制的语言（ Python、JavaScript）中，对象之间相互引用形成闭环，引用计数无法归零，导致无法释放内存。 |

* `内存泄漏`的`常见影响`，如下所示：

| 常见影响                         | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| :one: 内存占用持续增长           | 程序运行过程中，已分配但未释放的内存不断累积，导致内存使用量持续上升。 |
| :two: 系统性能下降或崩溃         | 长时间运行后，内存资源耗尽，系统变慢、响应延迟，严重时导致程序或系统崩溃（OOM）。 |
| :three: 程序在内存耗尽前仍可运行 | 内存泄漏初期表现不明显，程序看似正常，直到内存耗尽才暴露问题。 |

* `如何检测和避免`，如下所示：

| 如何检测         | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| :one: 如何检测？ | - **C/C++**: 使用 `Valgrind`、`AddressSanitizer`、Visual Studio 调试器分析内存使用。<br/>- **Java**: 使用 `JProfiler`、`jvisualvm`、`Eclipse MAT` 分析堆内存和对象引用。<br/>- **JavaScript**: 使用 Chrome DevTools 的 Memory 面板进行堆快照和内存录制。<br/>- **Python**: 使用 `tracemalloc`、`memory_profiler`、`objgraph` 检测对象引用和内存分配。 |
| :two: 如何避免？ | - 及时释放资源：确保 `malloc`/`new` 有对应 `free`/`delete`。<br/>- 使用自动资源管理机制：C++ 的 RAII 和智能指针（`unique_ptr`、`shared_ptr`），Java 的 `try-with-resources`。<br/>- 使用弱引用（`WeakReference`、`weakref`）避免长期持有对象。<br/>- 组件销毁时注销事件监听器、清除定时器（如 `removeEventListener`、`clearInterval`）。<br/>- 打破循环引用，合理设计对象关系。<br/>- 加强代码审查，结合自动化工具在 CI/CD 中检测内存问题。 |

### 1.2.2 内存溢出（Memory Overflow）

* `内存溢出`是指程序在申请内存时，`系统没有足够的可用内存分配给它`，导致分配失败，程序崩溃或抛出异常。

> [!NOTE]
>
> 📌 通俗理解：想借一本书，但图书馆已经没书可借了。

* `内存溢出`的`常见原因`，如下所示：

| 常见原因                  | 描述                                                         |
| ------------------------- | ------------------------------------------------------------ |
| :one: 内存泄漏累积        | - 长期未释放内存导致可用内存逐渐减少，最终在内存耗尽时引发溢出。<br>-  内存泄漏是导致内存溢出的常见间接原因。 |
| :two: 处理大量数据        | 程序需要加载超大文件、创建巨型数组或缓存大量对象，如：一次性读取 GB 级文件到内存。 |
| :three: 内存配置过小      | JVM 堆内存设置不足，如： `-Xmx512m` 但实际需求更大，导致 `java.lang.OutOfMemoryError: Java heap space`。 |
| :four: 递归过深导致栈溢出 | 深层递归或无限递归耗尽调用栈空间，引发 `StackOverflowError`（属于内存溢出的特殊形式）。 |

* `内存溢出`的`常见影响`，如下所示：

| 常见影响                 | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| :one: 程序崩溃或抛出异常 | 直接抛出内存溢出异常，如：Java 中的 `java.lang.OutOfMemoryError` 或 `StackOverflowError`，程序终止运行。 |
| :two: 系统不稳定         | 内存耗尽可能导致操作系统强制终止进程，或影响其他进程运行，系统整体响应变慢甚至宕机。 |

* `如何避免`：

| 如何避免                   | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| :one: 合理设置内存限制     | Java 中通过 `-Xmx`（最大堆内存）和 `-Xms`（初始堆内存）合理配置 JVM 内存。 |
| :two: 优化算法与数据处理   | 避免一次性加载大量数据，采用增量处理、懒加载等策略。         |
| :three: 使用流式处理与分页 | 对大文件使用 I/O 流逐块读取；数据库查询使用分页（pagination）避免全量加载。 |
| :four: 引入缓存控制机制    | 使用 LRU、TTL 等策略限制缓存大小，防止缓存无限增长。         |
| :five: 监控内存使用情况    | 利用监控工具，如：Prometheus + Grafana、JConsole、VisualVM，实时观察内存使用趋势，及时预警。 |

### 1.2.3 总结

* 如果我们写了一个服务器程序，那么：

| 应用场景 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 内存泄漏 | 每次处理请求都创建一个缓存对象，但从未清理旧对象 → 内存占用越来越高。 |
| 内存溢出 | 某次请求试图加载一个 10GB 的文件，而系统只有 8GB 可用内存 → 直接崩溃。 |

> [!NOTE]
>
> 📌 通俗理解： 
>
> * ① `内存泄漏`是“慢性病”**，**`内存溢出`是“急性发作”，有时慢性病最终引发了急性发作。
> * ② `内存泄漏`：该还的内存没还 → 资源浪费。
> * ③ `内存溢出`：想借的内存借不到 → 分配失败。
> * ④ `内存泄漏`可能最终导致`内存溢出`；但是，`内存溢出`不一定是因为`内存泄漏`。

* 内存泄漏 VS 内存溢出：

| 特性         | 内存泄漏（Memory Leak）                | 内存溢出（Memory Overflow） |
| ------------ | -------------------------------------- | --------------------------- |
| 本质         | 内存未释放，被“浪费”                   | 内存不够用，申请失败        |
| 是否一定崩溃 | 不一定，可能缓慢恶化                   | 通常导致程序崩溃            |
| 因果关系     | 可能导致内存溢出                       | 是结果，可能由泄漏引起      |
| 常见语言     | C/C++ 更严重；但是，Java/JS 也可能发生 | 所有语言都可能发生          |
| 典型表现     | 内存使用持续上升                       | 突然报错 “Out of Memory”    |

## 1.3 垃圾回收

### 1.3.1 手动垃圾回收

* 对于 C/C++ 这类没有自动垃圾回收机制的语言中，如果一个对象不再使用，就需要手动释放，否则就会出现`内存泄漏`。

![](./assets/2.svg)

* 这种释放对象的过程为`垃圾回收`，而需要程序员编写代码进行回收的方式称为`手动回收`。



* 示例：内存泄漏

::: code-group

```c [main.c]
#include <stdbool.h>
#include <stdlib.h>

int main() {
    
    while (true) {    // 死循环
        // 在堆区一直不停地创建 1024 个 int 大小的内存
        // 并且不释放，就会产生内存泄漏
        int* ptr = (int*) malloc(sizeof(int) * num); 
    }
    
    return 0;
}
```

```md:img [cmd 控制台]
```



:::



* 示例：无内存泄漏

::: code-group

```c [main.c]
#include <stdbool.h>
#include <stdlib.h>

int main() {
    
    while (true) {    // 死循环
        // 在堆区一直不停地创建 1024 个 int 大小的内存
        // 并且不释放，就会产生内存泄漏
        int* ptr = (int*) malloc(sizeof(int) * 1024); 
        
        // 手动释放内存
        if (ptr != NULL) {
            printf("Allocated memory for %d integers.\n", 1024);
            free(ptr);
    	}
    }
    
    return 0;
}
```

```md:img [cmd 控制台]

```



:::

### 1.3.2 自动垃圾回收

* Java 为了简化对象的释放，引入了自动的`垃圾回收`（Grabage Collection，简称 GC）机制，即：通过垃圾回收器对不再使用的对象完成自动回收。

> [!NOTE]
>
> * ① 垃圾回收器主要负责回收`堆`上不再使用的对象。
> * ② 很多现代化的编程语言，如：C#、Go 以及 Python 等都有自己的垃圾回收器。

![](./assets/3.svg)

* 垃圾回收器如果发现某个对象不再使用，就可以自动回收该对象。

> [!NOTE]
>
> 自动垃圾回收 ≠ 不会内存泄漏。不当使用静态引用、缓存、监听器等仍可能导致“逻辑泄漏”。 



* 示例：

::: code-group

```java
```

```md:img [cmd 控制台]

```

:::

### 1.3.3 手动垃圾回收 VS 自动垃圾回收

* 以下是`手动垃圾回收`与`自动垃圾回收`的对比表格：

| 对比维度     | 手动垃圾回收                                                 | 自动垃圾回收                                                 |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义         | 程序员显式分配和释放内存（如调用 `malloc`/`free`）。         | 由运行时系统自动检测并回收不再使用的内存。                   |
| 控制权       | 程序员完全控制内存生命周期。                                 | 运行时（GC）自动管理内存，程序员无需干预。                   |
| 典型语言     | C、C++                                                       | Java、Python、JavaScript、C#、Go、Ruby、Swift                |
| 内存分配函数 | `malloc`, `calloc`, `new`                                    | `new`（语言内置，无需手动释放）                              |
| 内存释放方式 | 必须显式调用 `free()` 或 `delete`                            | 无需手动释放，GC 自动回收不可达对象                          |
| 优点         | - 性能高，无 GC 开销<br>- 内存使用精确可控<br>- 适合实时系统 | - 减少内存泄漏风险<br>- 编程更安全、简洁<br>- 降低开发难度   |
| 缺点         | - 容易导致内存泄漏或悬空指针<br>- 编程复杂度高<br>- 易出错（如 double free） | - 存在 GC 停顿（影响实时性）<br>- 内存占用可能更高<br>- 不可预测的性能波动 |
| 常见问题     | 内存泄漏、野指针、重复释放、缓冲区溢出                       | GC 暂停（Stop-the-world）、内存占用高、延迟波动              |
| 性能特点     | 高效、低延迟、可预测                                         | 可能有停顿，吞吐量高但延迟不可控                             |
| 适用场景     | 嵌入式系统、操作系统、游戏引擎、高性能计算                   | Web 应用、企业级应用、移动开发、脚本语言                     |
| 资源管理机制 | RAII（C++）、智能指针（辅助）                                | 引用计数、标记-清除、分代收集、增量 GC 等                    |
| 调试工具     | Valgrind、AddressSanitizer、GDB                              | JVM Profiler、Chrome DevTools、Python tracemalloc            |
| 学习成本     | 较高，需理解内存模型                                         | 较低，开发者更关注业务逻辑                                   |

* 如果追求极致性能、低延迟或精细控制资源（操作系统、驱动、游戏引擎），选择手动回收。
* 如果追求开发效率、代码安全性和可维护性（ Web 后端、App 开发、脚本任务），选择自动回收。



# 第二章：









# 第三章：